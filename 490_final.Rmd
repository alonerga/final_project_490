---
title: "Extracellular Enzyme Assay Analysis from Samples in Panama"
author: "Andrew Lonergan"
date: "Fall 2019"
output: html_document
---

  
    
      
### Introduction

This is an R markdown file showing analysis of research I conducted in Dr. Andrew Steen's biogeochemistry lab. This markdown can be used as a reference for extracellular enzyme assay analyses, or in order to reproduce the analysis we did. 

#### Research background  
The goal of this project is to determine how extracellular enzymes are reacting with substrates in the various hot springs in which the samples were collected. We are hoping to understand if enzymes are following Michaelis Menten kinetics. 
Inline equations can be useful for displaying variables (greek or otherwise) like $K_m$ or $\mu$.

Display equations are set off from the rest of the text.
$$
v_o = \frac{V_{max} \times [S]}{K_m + [S]}
$$ 

### Initial steps  
We will use a variety of packages and sets of packages to analyze this data in R. Tidyverse is a set of packages meant for data science. Lubridate helps ease the complications surrounding dates and times in R. Devtools creates a directory structure for your packages. Lmstats provides vector summaries of linear models.


**tidyverse**, **lubridate**, **devtools**, and **lmstats**: Install the packages first, then load them in 

```{r, message = FALSE}
library(tidyverse)
library(lubridate)
library(devtools)
library(lmstats)
```

Read in your data from wherever it is stored in your drive. You can use glimpse to make sure it looks correct

```{r, message = FALSE}
mydata <- read.csv("/Users/AL/Desktop/geol490/final_project/2019_490_finaldata.csv")
glimpse(mydata)
```
    
#### Adjust data to improve time and date  

The time column in my csv represents at what time each fluorometer measurement was taken. Here we mutate our date and time so all measurements are placed on the same two hour time scale, and we call this elapsed hour. 

```{r, message = FALSE}
mydata <- read_csv("/Users/AL/Desktop/geol490/final_project/2019_490_finaldata.csv") %>%
  mutate(date.time = ymd_hms(paste("2020-01-01", Time))) %>%
  rename(filter.type = `Filter type`, filter.weight = `Filter weight`) %>%
  group_by(Site, Substrate, Cuvette, filter.type, filter.weight) %>%
  mutate(elapsed.hr = as.numeric(date.time -  min(date.time)) / 3600) # divide by 3600 to go from seconds to hours
```


#### Plot the raw data
Ggplot is a great way to map data in a professional looking manner

```{r}
p_raw <- ggplot(mydata, aes(x = elapsed.hr,
                            y = RFU,
                            color = filter.type)) +
  geom_point() +
  geom_smooth(aes(group = Cuvette),
              method = "lm",
              se = FALSE) +
  facet_wrap(Substrate~Site, scales = "free")

print(p_raw)
```

### Begin analysis 
Here we create a function that will create a dataframe comparing RFU to elapsed time. Lm_stats provides us with information such as the slope, intercept, and p value
```{r}
lm_fun <- function(df) {
  df <- as.data.frame(df)
  lm_stats(df, "elapsed.hr", "RFU")
}
```

#### Calculate slope, standard error and p value
```{r}
slopes <- mydata %>%
  nest() %>%
  mutate(lmstats_df = map(data, lm_fun)) %>%
  mutate(uncal.slope = map_dbl(lmstats_df, function(x) x[1, "slope"]),
         uncal.slope.se = map_dbl(lmstats_df, function(x) x[1, "slope.se"]),
         rsq = map_dbl(lmstats_df, function(x) x[1, "pval"]))
```
  
  
Make a column in the slopes data for which fluorophore goes with which substrate
```{r, warning = FALSE}
fluorophore_lookup <- data.frame(Substrate = unique(mydata$Substrate), 
                                 fluorophore = c("AMC",
                                                 "AMC",
                                                 "MUB",
                                                 "MUB",
                                                 "MUB"))
slopes <- slopes %>%
  left_join(fluorophore_lookup, by = "Substrate")
```


### Calibration data 
Our calibration data is how RFU changes with fluorophore concentration. Combining this with our previous substrate data we will be able to see enzymatic activity.

```{r, message = FALSE}
calib <- read_csv("/Users/AL/Desktop/geol490/final_project/2018_11_29_Calibration_Markdown.csv") %>%
  rename(conc.mM = `concentration (mM)`, fluorophore = sample) %>%
  mutate(conc.uM = conc.mM * 1000) 
```

#### Plot calibration data
```{r}
p_calib <- ggplot(calib, aes(x=conc.uM, 
                             y=RFU, 
                             colour = as.factor(temperature))) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) + 
  facet_wrap(~fluorophore)

print(p_calib) 
```

#### Create another function
This time for our calibration data
```{r}
calib_lm_fun <- function(df) {
  df <- as.data.frame(df)
  lm_stats(df, "conc.uM", "RFU")
}
```

#### Calculate slopes of the calibration curve
And create a column for it in the dataframe
```{r}
calib_slopes <- calib %>%
  group_by(fluorophore) %>%
  nest() %>%
  mutate(lmstats_df = map(data, calib_lm_fun),
         calib.slope = map_dbl(lmstats_df, function(x) x[1, "slope"])) %>%
  select(fluorophore, calib.slope)
```


### Combine datasets
Here we will combine our two dataets, dividing our slopes by the calibration slopes. First we are finding the mean filter slice weight.

```{r, warning = FALSE}
mean.filter.weight = 10 * mean(mydata$filter.weight)

rates <- slopes %>%
  left_join(calib_slopes, by = "fluorophore") %>%
  mutate(v0.unnorm = uncal.slope / calib.slope,
         v0.unnorm.se = uncal.slope.se / calib.slope,
         v0.norm = uncal.slope * 10 / 0.120,
         v0.norm.se = uncal.slope.se * (mean.filter.weight / filter.weight) / 0.120) 
```

#### Summarise rates by calulating mean rates
```{r}
rates_summ <- rates %>%
  group_by(Site, Substrate, filter.type) %>%
  summarise(mean.v0 = mean(v0.norm, na.rm = TRUE),
            v0.sd = sd(v0.norm, na.rm  = TRUE))
```

